<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>04_contructor属性</title>
</head>

<body>
    <script>
        /*
            使用 构造函数创建的对象本质都是 Constructor
            只要是 Constrcutor 都有 prototype 属性
            prototype对应的对象也是 Constructor
        */
        function Star(name) {
            this.name = name;
        }
        const foo = new Star('foo');
        console.log("@@@@@foo.constructor：");
        console.log(foo.constructor);
        console.log("@@@@@foo：");
        console.log(foo);
        console.log("@@@@@Star的 prototype：");
        console.log(Star.prototype);
        // 验证 Star.prototype.constructor 等于 Star
        console.log(Star.prototype.constructor === Star); // true
        // 此时给 Star的prototype 替换了一个新对象
        // 赋值前的Star.prototype:  {constructor: ƒ}
        console.log("赋值前的Star.prototype: ", Star.prototype);
        Star.prototype = {
            /*
            如果有多个对象的方法，我们可以给原型对象采取对象形式赋值
但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象constructor就不再指向当前构造函数了
此时，我们可以在修改后的原型对象中，添加一个constructor指向原来的构造函数。
            */
            constructor: Star,
            sing: function () { console.log("唱歌"); },
            dance: function () { console.log("跳舞"); }
        }
        // 赋值后的Star.prototype:  {constructor: ƒ, sing: ƒ, dance: ƒ}
        console.log("赋值后的Star.prototype: ", Star.prototype);
    </script>
</body>

</html>